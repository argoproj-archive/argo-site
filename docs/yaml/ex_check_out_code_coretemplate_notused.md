# Building a Container that Checks Out Code

In this topic, you'll use container templates again but the following template examples check out source code and create two different output artifacts. Here's what you'll accomplish:

*   Example 1 runs a container that clones the repo. The output artifact contains the source files.
*   Example 2 runs a container that clones the repo and builds the code. The output artifact contains the source files and the binary that was built.

## Example 1

NOTE: This is a core template that Applatix provides.

<div xmlns="">

type: container

name: axscm-checkout

description: Checks out commit to /src and export it as an artifact

inputs:

  parameters:

    commit:

      default: "%%session.commit%%"

    repo:

      default: "%%session.repo%%"

outputs:

  artifacts:

    code:

      path: /src

container:

  image: get.applatix.io/applatix/axscm:v1

  command: axscm clone %%repo%% /src --commit %%commit%%

  resources

    mem_mib: 256

    cpu_cores: 0.2

</div>

where:

*   `image: get.applatix.io/applatix/axscm:v1` indicates that the image is stored in the the Applatix Docker registry (which is a private registry) rather than the default Docker Hub registry.

    This container image contains various source control tools such as git and provides a generic wrapper command for checking out code no matter what source control system you are using

*   `repo` and `commit` are two input parameters that tell the container where to get the source code. The `default` statement indicates that the input parameters are optional, and if not specified, the values are filled in using the current session, which is generated by the Applatix Console or the Applatix Policy Manager that automatically runs jobs in response to a commit or push event.
*   `artifact` is a set of files that the container template generates. The set of files is named `code`. The artifact is created by collecting all the files that were checked out and stored in the `/src` directory.
*   `resources` is an optional keyword that specifies how much memory and cpu that <span class="GeneralApplatix Platform Name">Argo</span> reserves for running the container.

    By default, <span class="GeneralApplatix Platform Name">Argo</span> allocates 1000MiB (1GiB) and 1 CPU core for each container.

    The memory reservation (`mem_mib`) is also a hard limit. If your container exceeds the reservation, it will be terminated.

    The cpu reservation (`cpu_cores`) is not a hard limit but is used primarily for packing containers onto Kubernetes nodes and for share-based cpu allocation.

**TIP**: The default values are fine for most applications but you may want to override the defaults if your container can benefit from significantly more resources or if your container runs often and you want to reduce the cost of running the container.

## Example 2

Let's look at a container template that builds a Golang program:

<div xmlns="">

type: container

name: example-build

description: Build the code

inputs:

  artifacts:

  - from: "%%code%%"

    path: /src

  parameters:

    code:

outputs:

  artifacts:

    binary:

      path: /src/main

container:

  image: golang:1.6

  command: sh -c 'cd /src && ls -ltr && go build main.go'

</div>

where:

*   `image: golang:1.6` indicates that the golang image is retrieved from Docker Hub. The path for the source code is at `/src`.
*   `code` is the input artifact, which is unpacked and placed at `/src`.
*   `binary` is the name of the output artifact that the template generates. This artifact contains the source code as well as the result of the build.